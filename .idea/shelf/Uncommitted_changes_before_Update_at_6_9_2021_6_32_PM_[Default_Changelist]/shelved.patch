Index: app/src/main/java/com/example/uni_tok/AppNodeImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.uni_tok;\r\n\r\nimport android.os.Environment;\r\nimport android.util.Log;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.math.BigInteger;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.net.SocketAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.nio.file.FileAlreadyExistsException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.Map;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Scanner;\r\nimport java.util.TreeMap;\r\n\r\npublic class AppNodeImpl {\r\n\r\n    private static Socket requestSocket;\r\n    private static ObjectOutputStream objectOutputStream;\r\n    private static ObjectInputStream objectInputStream;\r\n\r\n    private static Channel channel;\r\n\r\n    private static TreeMap<Integer, SocketAddress> brokerHashes = new TreeMap<>();\r\n    private static SocketAddress channelBroker;\r\n\r\n    private static ServerSocket serverSocket;\r\n    private static InetAddress multicastIP;\r\n    private static int multicastPort;\r\n\r\n    private static SocketAddress hear_address;\r\n\r\n    private static ArrayList<String> subscribedToChannels = new ArrayList<>();\r\n    private static ArrayList<String> subscribedToHashtags = new ArrayList<>();\r\n\r\n    // --------------- MICHALIS CHANGES -------------- //\r\n    //private static HashMap<ChannelKey, String> searchVideoList = new HashMap<>();\r\n    private static ArrayList<VideoInformation> searchVideoList = new ArrayList<>();\r\n    private static LinkedHashMap<ChannelKey, String> homePageVideoList  = new LinkedHashMap<>();\r\n    // --------------- END OF MICHALIS CHANGES -------------- //\r\n\r\n\r\n    public static void main(String[] args) {\r\n\r\n        new AppNodeImpl().initialize(4960);\r\n    }\r\n\r\n    // --------------- MICHALIS CHANGES -------------- //\r\n\r\n    public static void init(int port) {\r\n        try {\r\n            serverSocket = new ServerSocket(port, 60, InetAddress.getLocalHost());\r\n\r\n            File uploadedDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).toString() + \"/Uploaded Videos/\");\r\n            uploadedDir.mkdirs();\r\n            File fetchedDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).toString() + \"/Fetched Videos/\");\r\n            fetchedDir.mkdirs();\r\n\r\n\r\n        } catch (IOException io) {\r\n            Log.d(\"Initialization Error\", \"Couldn't initialise App Node!\");\r\n        }\r\n    }\r\n\r\n    public static Channel getChannel() {\r\n        return channel;\r\n    }\r\n\r\n    public static void setChannel(Channel channel) {\r\n        AppNodeImpl.channel = channel;\r\n    }\r\n\r\n    public static void getBrokers() throws IOException, ClassNotFoundException {\r\n        objectOutputStream.writeObject(2);\r\n        objectOutputStream.flush();\r\n\r\n        brokerHashes = (TreeMap<Integer, SocketAddress>) objectInputStream.readObject();\r\n    }\r\n\r\n    public static boolean setChannelBroker(String name) throws IOException, ClassNotFoundException {\r\n        boolean unique;\r\n\r\n        //CHANNEL NAME\r\n        channel = new Channel(name);\r\n\r\n        //CONNECT TO APPROPRIATE BROKER\r\n        channelBroker = hashTopic(channel.getChannelName());\r\n        connect(channelBroker);\r\n\r\n        //SEND OPTION 4 FOR INITIALIZATION\r\n        objectOutputStream.writeObject(4);\r\n        objectOutputStream.flush();\r\n\r\n        //SEND CHANNEL NAME\r\n        objectOutputStream.writeObject(channel.getChannelName());\r\n        objectOutputStream.flush();\r\n\r\n        //SEND SOCKET ADDRESS FOR CONNECTIONS\r\n        init(4960);\r\n        String string_socket = serverSocket.getLocalSocketAddress().toString().split(\"/\")[1];\r\n        String[] array = string_socket.split(\":\");\r\n        InetAddress hear_ip = InetAddress.getByName(array[0]);\r\n        int hear_port = Integer.parseInt(array[1]);\r\n        hear_address = new InetSocketAddress(hear_ip, hear_port);\r\n        objectOutputStream.writeObject(hear_address);\r\n        objectOutputStream.flush();\r\n\r\n        //GET RESPONSE IF CHANNEL NAME IS UNIQUE\r\n        unique = (boolean) objectInputStream.readObject();\r\n\r\n        return unique;\r\n\r\n    }\r\n\r\n    public static boolean setSearchTopicVideoList(String topic) {\r\n\r\n        searchVideoList.clear();\r\n\r\n        boolean fetched_successfully = false;\r\n        //Get right broker\r\n        SocketAddress socketAddress = hashTopic(topic);\r\n\r\n        //Connect to that broker\r\n        connect(socketAddress);\r\n\r\n        try {\r\n            //Write option\r\n            objectOutputStream.writeObject(2);\r\n            objectOutputStream.flush();\r\n\r\n            //Write channel name or hashtag\r\n            objectOutputStream.writeObject(topic);\r\n            objectOutputStream.flush();\r\n\r\n            //Write this user's channel name\r\n            objectOutputStream.writeObject(channel.getChannelName());\r\n            objectOutputStream.flush();\r\n\r\n            //Read videoList\r\n            searchVideoList = (ArrayList<VideoInformation>) objectInputStream.readObject();\r\n\r\n            fetched_successfully = true;\r\n\r\n        } catch (IOException | ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            disconnect();\r\n        }\r\n\r\n        return fetched_successfully;\r\n    }\r\n\r\n    /**\r\n     * This page uploads to Home Page a video every time a\r\n     * channel or hashtag we are subscribed to uploads a video\r\n     */\r\n    public synchronized static void refreshHomePage(ChannelKey key, String title) {\r\n        homePageVideoList.put(key, title);\r\n    }\r\n\r\n    public static ArrayList<VideoInformation> getSearchTopicVideoList() {\r\n        return searchVideoList;\r\n    }\r\n\r\n    public static ArrayList<String> getSubscribedToChannels() {\r\n        return subscribedToChannels;\r\n    }\r\n\r\n    public static ArrayList<String> getSubscribedToHashtags() {\r\n        return subscribedToHashtags;\r\n    }\r\n\r\n    // --------------- END OF MICHALIS CHANGES -------------- //\r\n\r\n    public static boolean Upload(String path, ArrayList<String> associatedHashtags, String videoName){\r\n        VideoFile videoFile = new VideoFile(path, associatedHashtags, videoName);\r\n        HashMap<String, String> notificationHashtags = (AppNodeImpl.getChannel()).addVideoFile(videoFile);\r\n\r\n        if (!notificationHashtags.isEmpty()) {\r\n            for (Map.Entry<String, String> item : notificationHashtags.entrySet())\r\n                AppNodeImpl.notifyBrokersForHashTags(item.getKey(), item.getValue());\r\n        }\r\n\r\n        ChannelKey channelKey = new ChannelKey((AppNodeImpl.getChannel()).getChannelName(),\r\n                videoFile.getVideoID());\r\n        AppNodeImpl.notifyBrokersForChanges(channelKey, associatedHashtags, videoName, true);\r\n\r\n        return true;\r\n    }\r\n\r\n    // --------------- DIMITRIS CHANGES -------------- //\r\n\r\n    public static void handleRequest() {\r\n        try {\r\n            while(true) {\r\n                Socket connectionSocket = serverSocket.accept();\r\n                new ServeRequest(connectionSocket).start();\r\n            }\r\n        } catch(IOException e) {\r\n            /* Crash the server if IO fails. Something bad has happened. */\r\n            throw new RuntimeException(\"Could not create ServerSocket \", e);\r\n        } finally {\r\n            try {\r\n                serverSocket.close();\r\n            } catch (IOException | NullPointerException ioException) {\r\n                ioException.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    // --------------- END OF DIMITRIS CHANGES -------------- //\r\n\r\n\r\n    public void initialize(int port) {\r\n\r\n        //FIRST CONNECTION\r\n\r\n\r\n//            multicastIP = InetAddress.getByName(\"228.0.0.0\");\r\n//            multicastPort = 5000;\r\n\r\n\r\n        //GET BROKERS\r\n        connect();\r\n        try {\r\n            objectOutputStream.writeObject(2);\r\n            objectOutputStream.flush();\r\n\r\n            brokerHashes = (TreeMap<Integer, SocketAddress>) objectInputStream.readObject();\r\n        } catch (IOException | ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            disconnect();\r\n        }\r\n\r\n\r\n       // new RequestHandler(serverSocket).start();\r\n\r\n        runUser();\r\n\r\n    }\r\n\r\n    public static boolean addHashTag(VideoFile video, ArrayList<String> hashtagsAdded) {\r\n\r\n        ArrayList<String> hashtags = new ArrayList<>();\r\n        for (String hashtag : hashtagsAdded) {\r\n            if (!video.getAssociatedHashtags().contains(hashtag))\r\n                hashtags.add(hashtag);\r\n        }\r\n\r\n        if (hashtags.isEmpty()) {\r\n            Log.d(\"ADD HASHTAGS\", \"No hashtags found to add.\");\r\n        } else {\r\n\r\n            HashMap<String, String> notificationHashtags = channel.updateVideoFile(video, hashtags, \"ADD\");\r\n            if (!notificationHashtags.isEmpty()) {\r\n                for (Map.Entry<String, String> item : notificationHashtags.entrySet())\r\n                    notifyBrokersForHashTags(item.getKey(), item.getValue());\r\n            }\r\n\r\n            ChannelKey channelKey = new ChannelKey(channel.getChannelName(), video.getVideoID());\r\n            notifyBrokersForChanges(channelKey, hashtags, video.getVideoName(), false);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean removeHashTag(VideoFile video, ArrayList<String> hashtagsRemoved) {\r\n\r\n        ArrayList<String> hashtags = new ArrayList<>();\r\n        for (String hashtag : hashtagsRemoved) {\r\n            if (video.getAssociatedHashtags().contains(hashtag)) {\r\n                hashtags.add(hashtag);\r\n            }\r\n        }\r\n\r\n        if (hashtags.isEmpty()) {\r\n            Log.d(\"REMOVE HASHTAGS\", \"No hashtags found to remove.\");\r\n        } else {\r\n\r\n            HashMap<String, String> notificationHashtags = channel.updateVideoFile(video, hashtags, \"REMOVE\");\r\n            if (!notificationHashtags.isEmpty()) {\r\n                for (Map.Entry<String, String> item : notificationHashtags.entrySet())\r\n                    notifyBrokersForHashTags(item.getKey(), item.getValue());\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n//    @Override\r\n//    public List<Broker> getBrokerList() {\r\n//        return brokers;\r\n//    }\r\n\r\n    public static SocketAddress hashTopic(String hashtopic) {\r\n\r\n        int digest;\r\n        SocketAddress brokerAddress = brokerHashes.get(brokerHashes.firstKey());\r\n        try {\r\n            MessageDigest sha256 = MessageDigest.getInstance(\"SHA-256\");\r\n            //byte[] bb = sha256.digest(hashtopic.getBytes(StandardCharsets.UTF_8));\r\n            byte[] bb = sha256.digest(hashtopic.getBytes(Charset.forName(\"UTF-8\")));\r\n            BigInteger bigInteger = new BigInteger(1, bb);\r\n            digest = bigInteger.intValue();\r\n\r\n            //Fit to the right broker\r\n            for (int hash : brokerHashes.keySet()) {\r\n                if (digest <= hash) {\r\n                    brokerAddress = brokerHashes.get(hash);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        catch (NoSuchAlgorithmException nsae) {\r\n            nsae.printStackTrace();\r\n        } finally {\r\n            return brokerAddress;\r\n        }\r\n    }\r\n\r\n    public static void push(int id, ObjectInputStream objectInputStream, ObjectOutputStream objectOutputStream) throws NoSuchElementException {\r\n\r\n        ArrayList<byte[]> chunks = generateChunks(channel.getVideoFile_byID(id));\r\n\r\n        try {\r\n            objectOutputStream.writeObject(true);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(chunks.size());\r\n            objectOutputStream.flush();\r\n\r\n            while (!chunks.isEmpty()) {\r\n                byte[] clientToServer = chunks.remove(0);\r\n                objectOutputStream.write(clientToServer);\r\n                objectOutputStream.flush();\r\n            }\r\n        } catch (IOException ioException) {\r\n            ioException.printStackTrace();\r\n        }\r\n    }\r\n\r\n//    @Override\r\n//    public void notifyFailure(Broker broker) {\r\n//\r\n//    }\r\n\r\n    public static void notifyBrokersForHashTags(String hashtag, String action) {\r\n        SocketAddress socketAddress = hashTopic(hashtag);\r\n        connect(socketAddress);\r\n        try {\r\n            objectOutputStream.writeObject(7);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(hashtag);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(action);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(hear_address);\r\n            objectOutputStream.flush();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            disconnect();\r\n        }\r\n    }\r\n\r\n    public static void notifyBrokersForChanges(ChannelKey channelKey, ArrayList<String> hashtags, String title, boolean action) {\r\n\r\n        if (!hashtags.isEmpty()) {\r\n            for (String hashtag : hashtags) {\r\n                SocketAddress socketAddress = hashTopic(hashtag);\r\n                connect(socketAddress);\r\n                try {\r\n                    objectOutputStream.writeObject(8);\r\n                    objectOutputStream.flush();\r\n\r\n                    objectOutputStream.writeObject(\"hashtag\");\r\n                    objectOutputStream.flush();\r\n\r\n                    objectOutputStream.writeObject(hashtag);\r\n                    objectOutputStream.flush();\r\n\r\n                    objectOutputStream.writeObject(channelKey);\r\n                    objectOutputStream.flush();\r\n\r\n                    objectOutputStream.writeObject(title);\r\n                    objectOutputStream.flush();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    disconnect();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (action) {\r\n            SocketAddress socketAddress = hashTopic(channelKey.getChannelName());\r\n            connect(socketAddress);\r\n            try {\r\n                objectOutputStream.writeObject(8);\r\n                objectOutputStream.flush();\r\n\r\n                objectOutputStream.writeObject(\"channel\");\r\n                objectOutputStream.flush();\r\n\r\n                objectOutputStream.writeObject(channelKey);\r\n                objectOutputStream.flush();\r\n\r\n                objectOutputStream.writeObject(title);\r\n                objectOutputStream.flush();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            } finally {\r\n                disconnect();\r\n            }\r\n        }\r\n    }\r\n\r\n    public static ArrayList<byte[]> generateChunks(VideoFile video) {\r\n\r\n        ArrayList<byte[]> my_arraylist = new ArrayList<byte []>();\r\n\r\n        boolean flag = true;\r\n        int i = 0;\r\n        byte[] inputBuffer = video.getVideoFileChunk();\r\n\r\n        while (i < inputBuffer.length) {\r\n            byte[] buffer = new byte[4096];\r\n            for (int j = 0;j < buffer.length;j++) {\r\n                if (i < inputBuffer.length)\r\n                    buffer[j] = inputBuffer[i++];\r\n            }\r\n            my_arraylist.add(buffer);\r\n        }\r\n        return my_arraylist;\r\n    }\r\n\r\n//    public TreeMap<Integer, SocketAddress> getBrokerMap() {\r\n//\r\n//        connect();\r\n//        try {\r\n//            objectOutputStream.writeObject(2);\r\n//            objectOutputStream.flush();\r\n//\r\n//            brokerHashes = (TreeMap<Integer, SocketAddress>) objectInputStream.readObject();\r\n//        } catch (IOException | ClassNotFoundException e) {\r\n//            e.printStackTrace();\r\n//        } finally {\r\n//            disconnect();\r\n//        }\r\n//        return brokerHashes;\r\n\r\n        /*\r\n        System.out.println(\"I am in here\");\r\n        try {\r\n            serverSocket = new ServerSocket(4950, 60, InetAddress.getLocalHost());\r\n            updateNodes();\r\n            serverSocket.setSoTimeout(2000);\r\n            try {\r\n                Socket connectionSocket = serverSocket.accept();\r\n                ObjectInputStream objectInputStream = new ObjectInputStream(connectionSocket.getInputStream());\r\n                int option = (int) objectInputStream.readObject();\r\n                brokerHashes = (TreeMap<Integer, SocketAddress>) objectInputStream.readObject();\r\n            } catch (SocketTimeoutException ste) {\r\n                System.out.println(\"Can't connect to a server. Terminating....\");\r\n                System.exit(-1);\r\n            } catch (ClassNotFoundException e) {\r\n                e.printStackTrace();\r\n            }\r\n            serverSocket.setSoTimeout(0);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return null;\r\n        */\r\n\r\n//    }\r\n\r\n    public static void connect(SocketAddress socketAddress) {\r\n\r\n        try {\r\n            Log.d(\"Enter connection\", \"Enter connection\");\r\n            requestSocket = new Socket();\r\n            requestSocket.connect(socketAddress);\r\n            requestSocket.setSoTimeout(0);\r\n            Log.d(\"Connected!\", \"Connected!\");\r\n            objectOutputStream = new ObjectOutputStream(requestSocket.getOutputStream());\r\n            objectInputStream = new ObjectInputStream(requestSocket.getInputStream());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static void connect() {\r\n\r\n        try {\r\n            Scanner in5 = new Scanner(System.in);\r\n            System.out.println(\"Give Address Keeper IP address : \");\r\n            String inetAddress = in5.nextLine();\r\n            requestSocket = new Socket(InetAddress.getByName(inetAddress), 4000);\r\n            objectOutputStream = new ObjectOutputStream(requestSocket.getOutputStream());\r\n            objectInputStream = new ObjectInputStream(requestSocket.getInputStream());\r\n        } catch (UnknownHostException unknownHost) {\r\n            System.err.println(\"You are trying to connect to an unknown host.\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static void disconnect() {\r\n        try {\r\n            objectInputStream.close();\r\n            objectOutputStream.close();\r\n            requestSocket.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n//    @Override\r\n//    public void updateNodes() throws IOException {\r\n//\r\n//        System.out.println(\"In update Nodes\");\r\n//\r\n//        MulticastSocket socket = new MulticastSocket(multicastPort);\r\n//        socket.joinGroup(multicastIP);\r\n//\r\n//        //SEND % AND SOCKET ADDRESS TO RECEIVE BROKERHASHES\r\n//        String appNodeChar = \"%\";\r\n//        String address = serverSocket.getLocalSocketAddress().toString();\r\n//        String appNodeChar_address = appNodeChar + \",\" + address;\r\n//        byte[] buffer = appNodeChar_address.getBytes();\r\n//\r\n//        //MAKE PACKET AND SEND IT\r\n//        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, multicastIP, multicastPort);\r\n//        socket.send(packet);\r\n//\r\n//        try {\r\n//            TimeUnit.SECONDS.sleep(2000);\r\n//        } catch (InterruptedException e) {\r\n//            e.printStackTrace();\r\n//        }\r\n//\r\n//        System.out.println(\"Packet sent\");\r\n//\r\n//        socket.leaveGroup(multicastIP);\r\n//\r\n//        //CLOSE SOCKET\r\n//        socket.close();\r\n//\r\n//    }\r\n\r\n\r\n    public static boolean register(SocketAddress socketAddress, String topic) {\r\n\r\n        connect(socketAddress);\r\n        boolean successful_subscription = false;\r\n\r\n        try {\r\n            objectOutputStream.writeObject(1);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(channel.getChannelName());\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(topic);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(hear_address);\r\n            objectOutputStream.flush();\r\n\r\n            String response = (String) objectInputStream.readObject();\r\n            Log.d(\"RESPONSE\", response);\r\n\r\n            if (response.contains(\"successfully\")) {\r\n                if (topic.charAt(0) == '#') {\r\n                    subscribedToHashtags.add(topic);\r\n                } else {\r\n                    subscribedToChannels.add(topic);\r\n                }\r\n                successful_subscription = true;\r\n            }\r\n\r\n        } catch (IOException | ClassNotFoundException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            disconnect();\r\n        }\r\n\r\n        return successful_subscription;\r\n    }\r\n\r\n    public static boolean unregister(SocketAddress socketAddress, String topic) {\r\n\r\n        boolean successful_unsubscription = false;\r\n\r\n        try {\r\n            connect(socketAddress);\r\n\r\n            objectOutputStream.writeObject(9);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(topic);\r\n            objectOutputStream.flush();\r\n\r\n            objectOutputStream.writeObject(hear_address);\r\n            objectOutputStream.flush();\r\n\r\n            if (topic.charAt(0) == '#'){\r\n                subscribedToHashtags.remove(topic);\r\n            } else {\r\n                subscribedToChannels.remove(topic);\r\n            }\r\n            successful_unsubscription = true;\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            disconnect();\r\n        }\r\n\r\n        return successful_unsubscription;\r\n    }\r\n\r\n    public static void playData(HashMap<ChannelKey, String> videoList) {\r\n\r\n        File nf = null;\r\n        Scanner in2 = new Scanner(System.in);\r\n\r\n        try {\r\n            System.out.print(\"Give the Channel Name that you want to play: \");\r\n            String channelName = in2.nextLine();\r\n\r\n            System.out.print(\"Give the video ID that you want to play: \");\r\n            int videoID = in2.nextInt();\r\n\r\n            ChannelKey key = new ChannelKey(channelName, videoID);\r\n\r\n            if (!videoList.containsKey(key)){\r\n                System.out.println(\"This combination of channel name and id doesn't exist.\");\r\n            } else {\r\n                //CONNECTING TO BROKER RESPONSIBLE FOR CHANNEL, THAT HAS THE VIDEO WE ASKED FOR\r\n                SocketAddress brokerAddress = hashTopic(channelName);\r\n                connect(brokerAddress);\r\n\r\n                objectOutputStream.writeObject(3);\r\n                objectOutputStream.flush();\r\n\r\n                objectOutputStream.writeObject(key);\r\n                objectOutputStream.flush();\r\n\r\n                //RECEIVE VIDEO FILE CHUNKS\r\n                byte[] chunk;\r\n                ArrayList<byte[]> chunks = new ArrayList<>();\r\n                int size = (int) objectInputStream.readObject();\r\n\r\n                if (size == 0) {\r\n                    System.out.println(\"CHANNEL HAS NO VIDEO WITH THIS ID...\");\r\n                }\r\n                //REBUILD CHUNKS FOR TESTING\r\n                else {\r\n                    for (int i = 0; i < size; i++) {\r\n                        chunk = new byte[4096];\r\n                        objectInputStream.readFully(chunk);\r\n                        //chunk = objectInputStream.readAllBytes();\r\n                        chunks.add(chunk);\r\n                    }\r\n                    try {\r\n                        nf = new File(\"Fetched Videos\\\\\" + channel.getChannelName() + \"_\"\r\n                                + channelName + \"_\" + videoID + \".mp4\");\r\n                        for (byte[] ar : chunks) {\r\n                            FileOutputStream fw = new FileOutputStream(nf, true);\r\n                            try {\r\n                                fw.write(ar);\r\n                            } finally {\r\n                                fw.close();\r\n                            }\r\n                        }\r\n\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    } finally {\r\n                        disconnect();\r\n                    }\r\n                }\r\n            }\r\n        } catch(IOException | ClassNotFoundException e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static HashMap<ChannelKey, String> getChannelVideoMap() {\r\n        return channel.getChannelVideoNames();\r\n    }\r\n\r\n    public static HashMap<ChannelKey, ArrayList<String>> getChannelHashtagsMap() {\r\n        return channel.getChannelAssociatedHashtags();\r\n    }\r\n\r\n    public static HashMap<ChannelKey, String> getHashtagVideoMap(String hashtag) {\r\n        return channel.getChannelVideoNamesByHashtag(hashtag);\r\n    }\r\n\r\n/*\r\n    //CHANGES HAVE BEEN MADE\r\n    class RequestHandler extends Thread {\r\n\r\n        public ServerSocket serverSocket;\r\n        public Socket connectionSocket;\r\n\r\n        public RequestHandler(ServerSocket serverSocket) {\r\n            this.serverSocket = serverSocket;\r\n        }\r\n\r\n        public void run() {\r\n\r\n            try {\r\n                while(true) {\r\n                    connectionSocket = serverSocket.accept();\r\n                    new ServeRequest(connectionSocket).start();\r\n                }\r\n            } catch(IOException e) {\r\n                //Crash the server if IO fails. Something bad has happened.\r\n                throw new RuntimeException(\"Could not create ServerSocket \", e);\r\n            } finally {\r\n                try {\r\n                    serverSocket.close();\r\n                } catch (IOException | NullPointerException ioException) {\r\n                    ioException.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    */\r\n/*\r\n    class ServeRequest extends Thread {\r\n\r\n        private Socket socket;\r\n        private ObjectInputStream objectInputStream;\r\n        private ObjectOutputStream objectOutputStream;\r\n\r\n        ServeRequest(Socket s) {\r\n            socket = s;\r\n            try {\r\n                objectOutputStream = new ObjectOutputStream(socket.getOutputStream());\r\n                objectInputStream = new ObjectInputStream(socket.getInputStream());\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n6\r\n        public void run() {\r\n\r\n            try{\r\n\r\n                int option = (int) objectInputStream.readObject();\r\n\r\n                if (option == 1) { //Pull List\r\n\r\n                    //Choice between sending whole channel or files based on hashtag\r\n                    String choice = (String) objectInputStream.readObject();\r\n                    System.out.println(choice);\r\n                    if (choice.equals(\"CHANNEL\")) {\r\n                        HashMap<ChannelKey, String> videoList = getChannelVideoMap();\r\n                        objectOutputStream.writeObject(videoList);\r\n                    }\r\n                    else {\r\n                        HashMap<ChannelKey, String> videoList = getHashtagVideoMap(choice);\r\n                        objectOutputStream.writeObject(videoList);\r\n                    }\r\n\r\n                } else if (option == 2) { //Pull Video\r\n\r\n                    ChannelKey channelKey = (ChannelKey) objectInputStream.readObject();\r\n                    try {\r\n                        push(channelKey.getVideoID(), objectInputStream, objectOutputStream);\r\n                    } catch (NoSuchElementException nsee) {\r\n                        objectOutputStream.writeObject(false);\r\n                        objectOutputStream.flush();\r\n                    }\r\n\r\n                } else if (option == 3) {\r\n\r\n                    String notificationMessage = (String) objectInputStream.readObject();\r\n                    System.out.println(notificationMessage);\r\n\r\n                }\r\n            } catch (IOException | ClassNotFoundException e) {\r\n                e.printStackTrace();\r\n            } finally {\r\n                try {\r\n                    objectInputStream.close();\r\n                    objectOutputStream.close();\r\n                    socket.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n*/\r\n    public void runUser() {\r\n        //BUILD INTERFACE\r\n        Scanner in = new Scanner(System.in);\r\n        int end = 0;\r\n        String choice;\r\n        do {\r\n            System.out.println(\"\\n===== Menu =====\");\r\n            //Consumer Methods\r\n            System.out.println(\"1. Register User to hashtag or channel\");\r\n            System.out.println(\"2. Get Topic Video List\");\r\n            System.out.println(\"3. Unregister User from hashtag or channel\");\r\n            //Publisher Methods\r\n            System.out.println(\"4. Add Hashtags to a Video\");\r\n            System.out.println(\"5. Remove Hashtags from a Video\");\r\n            System.out.println(\"6. Upload Video\");\r\n            System.out.println(\"7. Delete Video\");\r\n            System.out.println(\"8. Check Profile\");\r\n            System.out.println(\"0. Exit\");\r\n            choice = in.nextLine();\r\n            if (choice.equals(\"1\")) {\r\n\r\n                String topic;\r\n                System.out.print(\"Please select a topic (hashtag/channel) that you want to subscribe: \");\r\n                topic = in.nextLine();\r\n                SocketAddress socketAddress = hashTopic(topic);\r\n                register(socketAddress, topic);\r\n\r\n            } else if (choice.equals(\"2\")) {\r\n\r\n                //Give hashtag\r\n                System.out.print(\"Please give the hashtag or the channel that you want to search for: \");\r\n                String channel_or_hashtag = in.nextLine();\r\n\r\n                //Get right broker\r\n                SocketAddress socketAddress = hashTopic(channel_or_hashtag);\r\n\r\n                //Connect to that broker\r\n                connect(socketAddress);\r\n\r\n                HashMap<ChannelKey, String> videoList = new HashMap<>();\r\n\r\n                try {\r\n                    //Write option\r\n                    objectOutputStream.writeObject(2);\r\n                    objectOutputStream.flush();\r\n\r\n                    //Write channel name or hashtag\r\n                    objectOutputStream.writeObject(channel_or_hashtag);\r\n                    objectOutputStream.flush();\r\n\r\n                    //Write this user's channel name\r\n                    objectOutputStream.writeObject(channel.getChannelName());\r\n                    objectOutputStream.flush();\r\n\r\n                    //Read videoList\r\n                    videoList = (HashMap<ChannelKey, String>) objectInputStream.readObject();\r\n                } catch (IOException | ClassNotFoundException e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    disconnect();\r\n                }\r\n\r\n                boolean wantVideo = true;\r\n                if (videoList.isEmpty()) {\r\n                    System.out.println(\"No videos\\n\");\r\n                    wantVideo = false;\r\n                }\r\n                //CHOOSE SOME VIDEO OR GO BACK\r\n                while (wantVideo) {\r\n                    for (Map.Entry<ChannelKey, String> item : videoList.entrySet()) {\r\n                        System.out.println(\"Channel Name : \" + item.getKey().getChannelName() + \"     Video ID : \"\r\n                                + item.getKey().getVideoID() + \"    Video Name : \" +item.getValue());\r\n                    }\r\n\r\n                    System.out.print(\"Do you want to see a video from these? (y/n)\");\r\n                    String answer = in.nextLine();\r\n\r\n                    if (answer.equals(\"y\")) {\r\n                        playData(videoList);\r\n                    } else wantVideo = false;\r\n                }\r\n\r\n            } else if (choice.equals(\"3\")) {\r\n\r\n                String topic;\r\n                System.out.print(\"Please select 'channel' if you want to unsubscribe from a channel \" +\r\n                        \"or 'hashtag' to unsubscribe from a hashtag: \");\r\n                topic = in.nextLine();\r\n\r\n                if (topic.equals(\"channel\")){\r\n                    boolean wantUnsubscribe = true;\r\n                    Scanner in2 = new Scanner(System.in);\r\n                    String answer = \"\";\r\n                    while (wantUnsubscribe){\r\n                        if (subscribedToChannels.isEmpty()){\r\n                            if (answer.equals(\"\"))\r\n                                System.out.println(\"You aren't subscribed to any channel. Unsubscribe cancelled...\");\r\n                            answer = \"n\";\r\n                        } else {\r\n                            System.out.println(\"Channels that you are subscribed: \");\r\n                            for (String channel : subscribedToChannels)\r\n                                System.out.println(channel);\r\n                            System.out.println(\"Do you want to unsubscribe from one of the above channels? (y/n)\");\r\n                            answer = in2.nextLine();\r\n                        }\r\n\r\n                        if (answer.equals(\"y\")){\r\n                            try {\r\n                                System.out.println(\"Give me the channel name that you want to unsubscribe: \");\r\n                                String channelName = in2.nextLine();\r\n\r\n                                if (!subscribedToChannels.contains(channelName)) {\r\n                                    System.out.println(\"You are not subscribed to channel \" + channelName);\r\n                                    continue;\r\n                                }\r\n\r\n                                subscribedToChannels.remove(channelName);\r\n\r\n                                SocketAddress socketAddress1 = hashTopic(channelName);\r\n\r\n                                unregister(socketAddress1, channelName);\r\n\r\n                            } catch (Exception e) {\r\n                                e.printStackTrace();\r\n                            }\r\n                        } else {\r\n                            wantUnsubscribe = false;\r\n                        }\r\n                    }\r\n                } else if (topic.equals(\"hashtag\")){\r\n                    boolean wantUnsubscribe = true;\r\n                    Scanner in2 = new Scanner(System.in);\r\n                    String answer = \"\";\r\n                    while (wantUnsubscribe){\r\n                        if (subscribedToHashtags.isEmpty()){\r\n                            if (answer.equals(\"\"))\r\n                                System.out.println(\"You aren't subscribed to any hashtag. Unsubscribe cancelled...\");\r\n                            answer = \"n\";\r\n                        } else {\r\n                            System.out.println(\"Hashtags that you are subscribed: \");\r\n                            for (String hashtag : subscribedToHashtags)\r\n                                System.out.println(hashtag);\r\n                            System.out.println(\"Do you want to unsubscribe from one of the above hashtags? (y/n)\");\r\n                            answer = in2.nextLine();\r\n                        }\r\n\r\n                        if (answer.equals(\"y\")){\r\n                            try {\r\n                                System.out.println(\"Give me the hashtag that you want to unsubscribe: \");\r\n                                String hashtag = in2.nextLine();\r\n\r\n                                if (!subscribedToHashtags.contains(hashtag)) {\r\n                                    System.out.println(\"You are not subscribed to hashtag \" + hashtag);\r\n                                    continue;\r\n                                }\r\n\r\n                                subscribedToHashtags.remove(hashtag);\r\n\r\n                                SocketAddress socketAddress1 = hashTopic(hashtag);\r\n\r\n                                unregister(socketAddress1, hashtag);\r\n\r\n                            } catch (Exception e) {\r\n                                e.printStackTrace();\r\n                            }\r\n                        } else {\r\n                            wantUnsubscribe = false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    System.out.println(\"You didn't choose 'channel' or 'hashtag'. Unsubscribe cancelled...\");\r\n                }\r\n\r\n            } else if (choice.equals(\"4\")) {\r\n\r\n                int videoID;\r\n\r\n                if (channel.getID_VideoFileMap().isEmpty()) {\r\n                    System.out.println(\"The channel doesn't have any videos to add hashtags.\");\r\n                    continue;\r\n                }\r\n\r\n                System.out.println(channel.toString());\r\n\r\n                System.out.print(\"Please give the videoID of the video you want to add a hashtag: \");\r\n                videoID = Integer.parseInt(in.nextLine());\r\n\r\n                VideoFile video = channel.getVideoFile_byID(videoID);\r\n\r\n//                addHashTag(video);\r\n\r\n            } else if (choice.equals(\"5\")) {\r\n\r\n                int videoID;\r\n\r\n                if (channel.getID_VideoFileMap().isEmpty()) {\r\n                    System.out.println(\"The channel doesn't have any videos to remove hashtags.\");\r\n                    continue;\r\n                }\r\n\r\n                System.out.println(channel.toString());\r\n\r\n                System.out.print(\"Please give the videoID of the video you want to remove a hashtag: \");\r\n                videoID = Integer.parseInt(in.nextLine());\r\n\r\n                VideoFile video = channel.getVideoFile_byID(videoID);\r\n\r\n                //removeHashTag(video);\r\n\r\n            } else if (choice.equals(\"6\")) {\r\n\r\n//                JFileChooser chooser = new JFileChooser(){\r\n//                    @Override\r\n//                    protected JDialog createDialog(Component parent) throws HeadlessException {\r\n//                        JDialog jDialog = super.createDialog(parent);\r\n//                        jDialog.setAlwaysOnTop(true);\r\n//                        return jDialog;\r\n//                    }\r\n//                };\r\n//                FileNameExtensionFilter filter = new FileNameExtensionFilter(\".mp4\", \"mp4\");\r\n//                chooser.setFileFilter(filter);\r\n//                int returnVal = chooser.showOpenDialog(null);\r\n//                if (returnVal == JFileChooser.APPROVE_OPTION) {\r\n//                    System.out.println(\"You chose to upload this file: \"+chooser.getSelectedFile().getAbsolutePath());\r\n//\r\n//                    ArrayList<String> associatedHashtags = new ArrayList<>();\r\n//\r\n//                    String filepath = chooser.getSelectedFile().getAbsolutePath();\r\n//\r\n//                    String videoTitle = chooser.getSelectedFile().getName().split(\"\\\\.\")[0];\r\n//\r\n//                    String hashtag;\r\n//                    while (true) {\r\n//                        System.out.print(\"Do you want to add a hashtag to your video? (y/n) \");\r\n//                        String answer = in.nextLine();\r\n//                        if (answer.equals(\"n\")) {\r\n//                            break;\r\n//                        }\r\n//\r\n//                        System.out.print(\"Please give a hashtag for the video: \");\r\n//                        hashtag = in.nextLine();\r\n//\r\n//                        if (!associatedHashtags.contains(hashtag)) {\r\n//                            associatedHashtags.add(hashtag);\r\n//                        }\r\n//                    }\r\n//\r\n//                    VideoFile video = new VideoFile(filepath, associatedHashtags, videoTitle);\r\n//\r\n//                    HashMap<String, String> notificationHashtags = channel.addVideoFile(video);\r\n//\r\n//                    boolean notExists = true;\r\n//                    try {\r\n//                        Path source = Paths.get(filepath);\r\n//                        Path target = Paths.get(\"Uploaded Videos\\\\\" + videoTitle + \".mp4\");\r\n//                        Files.copy(source, target);\r\n//                    } catch (IOException e) {\r\n//                        if (e instanceof FileAlreadyExistsException) {\r\n//                            System.out.println(\"There is already a video with that name. Upload cancelled...\\n\");\r\n//                        }\r\n//                        notExists = false;\r\n//                    }\r\n//\r\n//                    if (notExists) {\r\n//                        if (!notificationHashtags.isEmpty()) {\r\n//                            for (Map.Entry<String, String> item : notificationHashtags.entrySet())\r\n//                                notifyBrokersForHashTags(item.getKey(), item.getValue());\r\n//                        }\r\n//\r\n//                        ChannelKey channelKey = new ChannelKey(channel.getChannelName(), video.getVideoID());\r\n//                        notifyBrokersForChanges(channelKey, associatedHashtags, videoTitle, true);\r\n//                    } else {\r\n//                        channel.removeVideoFile(video);\r\n//                    }\r\n//                } else {\r\n//                    System.out.println(\"You didn't choose any file. Upload cancelled...\");\r\n//                }\r\n\r\n                String filepath;\r\n                String videoTitle;\r\n                String hashtag;\r\n                ArrayList<String> associatedHashtags = new ArrayList<>();\r\n\r\n                System.out.print(\"Please give the path of the video you want to upload: \");\r\n                filepath = in.nextLine();\r\n\r\n                System.out.print(\"Title of the video: \");\r\n                videoTitle = in.nextLine();\r\n\r\n                while (true) {\r\n                    System.out.print(\"Do you want to add a hashtag to your video? (y/n) \");\r\n                    String answer = in.nextLine();\r\n                    if (answer.equals(\"n\")) {\r\n                        break;\r\n                    }\r\n\r\n                    System.out.print(\"Please give a hashtag for the video: \");\r\n                    hashtag = in.nextLine();\r\n\r\n                    if (!associatedHashtags.contains(hashtag)) {\r\n                        associatedHashtags.add(hashtag);\r\n                    }\r\n                }\r\n\r\n                VideoFile video = new VideoFile(filepath, associatedHashtags, videoTitle);\r\n\r\n                HashMap<String, String> notificationHashtags = channel.addVideoFile(video);\r\n                boolean notExists = true;\r\n                try {\r\n                    Path source = Paths.get(filepath);\r\n                    Path target = Paths.get(\"Uploaded Videos\\\\\" + videoTitle + \".mp4\");\r\n                    Files.copy(source, target);\r\n                } catch (IOException e) {\r\n                    if (e instanceof FileAlreadyExistsException) {\r\n                        System.out.println(\"There is already a video with that name. Upload cancelled...\\n\");\r\n                    }\r\n                    e.printStackTrace();\r\n                    notExists = false;\r\n                }\r\n\r\n                if (notExists) {\r\n                    if (!notificationHashtags.isEmpty()) {\r\n                        for (Map.Entry<String, String> item : notificationHashtags.entrySet())\r\n                            notifyBrokersForHashTags(item.getKey(), item.getValue());\r\n                    }\r\n\r\n                    ChannelKey channelKey = new ChannelKey(channel.getChannelName(), video.getVideoID());\r\n                    notifyBrokersForChanges(channelKey, associatedHashtags, videoTitle, true);\r\n                } else {\r\n                    channel.removeVideoFile(video);\r\n                }\r\n            }\r\n\r\n            else if (choice.equals(\"7\")){\r\n\r\n                int videoID;\r\n\r\n                if (channel.getID_VideoFileMap().isEmpty()) {\r\n                    System.out.println(\"The channel doesn't have any videos to delete.\");\r\n                    continue;\r\n                }\r\n\r\n                System.out.println(channel.toString());\r\n\r\n                System.out.print(\"Please give the ID of the video you want to delete: \");\r\n                videoID = Integer.parseInt(in.nextLine());\r\n\r\n                VideoFile video = channel.getVideoFile_byID(videoID);\r\n\r\n                HashMap<String, String> notificationHashtags = channel.removeVideoFile(video);\r\n\r\n                try {\r\n                    Path file = Paths.get(\"Uploaded Videos\\\\\" + video.getVideoName() + \".mp4\");\r\n                    Files.delete(file);\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n\r\n                if (!notificationHashtags.isEmpty()) {\r\n                    for (Map.Entry<String, String> item : notificationHashtags.entrySet())\r\n                        notifyBrokersForHashTags(item.getKey(), item.getValue());\r\n                }\r\n\r\n            }else if (choice.equals(\"8\")) {\r\n\r\n                System.out.println(channel);\r\n\r\n            }else if (choice.equals(\"0\")) {\r\n\r\n                end = 1;\r\n\r\n            }\r\n        } while (end == 0);\r\n\r\n        System.exit(0);\r\n\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/uni_tok/AppNodeImpl.java	(revision 6d574023080f3aa74dcdad555876e362692a4df7)
+++ app/src/main/java/com/example/uni_tok/AppNodeImpl.java	(date 1623252694461)
@@ -74,7 +74,6 @@
             File fetchedDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).toString() + "/Fetched Videos/");
             fetchedDir.mkdirs();
 
-
         } catch (IOException io) {
             Log.d("Initialization Error", "Couldn't initialise App Node!");
         }
